"""Public programmatic API for OpenSloth."""

from __future__ import annotations

import json
import os
import pprint
import subprocess
import sys
import tempfile
import textwrap
from pathlib import Path
from typing import TYPE_CHECKING, Tuple

from opensloth.opensloth_config import (
    DatasetPrepConfig,
    OpenSlothConfig,
    TrainingArguments,
)
from opensloth.trainer_factory.opensloth_trainer import (
    run_mp_training,
    run_tmux_training,
    setup_envs,
)


def _serialise_configs_to_temp(
    opensloth_config: OpenSlothConfig, training_args: TrainingArguments
) -> Path:
    tmp_dir = Path(tempfile.mkdtemp(prefix="opensloth_cli_"))
    cfg_path = tmp_dir / "_tmux_config.py"
    code = textwrap.dedent(
        f"""# Auto-generated by OpenSloth API (tmux launch)
import json
from opensloth.opensloth_config import OpenSlothConfig, TrainingArguments
_opensloth_cfg_json = r'''{json.dumps(opensloth_config.model_dump())}'''
_training_args_json = r'''{json.dumps(training_args.model_dump())}'''
opensloth_config = OpenSlothConfig(**json.loads(_opensloth_cfg_json))
training_config = TrainingArguments(**json.loads(_training_args_json))
"""
    )
    cfg_path.write_text(code)
    return cfg_path


def _generate_training_script(
    opensloth_config: OpenSlothConfig, training_args: TrainingArguments
) -> str:
    """Generates a standalone Python script from config objects."""

    # Convert Pydantic models to dictionaries
    opensloth_config_dict = opensloth_config.model_dump()
    training_args_dict = training_args.model_dump()

    # Use pprint to create a nicely formatted, human-readable string
    opensloth_config_str = pprint.pformat(opensloth_config_dict, indent=4, width=100)
    training_args_str = pprint.pformat(training_args_dict, indent=4, width=100)

    script_template = f"""# =============================================================================
# THIS SCRIPT WAS AUTO-GENERATED BY THE OPENSLOTH CLI
# =============================================================================
#
# It contains the exact configuration for a training run, making it fully
# reproducible and easy to modify for future experiments.
#
# To run this script directly:
# python train.py
#
# =============================================================================

from opensloth.opensloth_config import OpenSlothConfig, TrainingArguments
from opensloth.trainer_factory.opensloth_trainer import setup_envs, run_mp_training

# --- Configuration Dictionaries ---

opensloth_config_dict = {opensloth_config_str}

training_args_dict = {training_args_str}


# --- Main Execution ---

if __name__ == "__main__":
    # Load configs from dictionaries
    opensloth_config = OpenSlothConfig(**opensloth_config_dict)
    training_config = TrainingArguments(**training_args_dict)

    # Setup environment and run training
    setup_envs(opensloth_config, training_config)
    run_mp_training(opensloth_config.devices, opensloth_config, training_config)

    print("\\nğŸ‰ Training script finished successfully! âœ¨")
"""
    return script_template


def run_training(
    opensloth_config: OpenSlothConfig,
    training_args: TrainingArguments,
    *,
    use_tmux: bool = False,
    tmux_session: str | None = None,
    tmux_auto_kill: bool = False,
) -> tuple[OpenSlothConfig, TrainingArguments]:
    setup_envs(opensloth_config, training_args)
    multi_gpu = len(opensloth_config.devices) > 1

    if use_tmux and not multi_gpu:
        use_tmux = False
    if use_tmux and multi_gpu:
        # Set USE_TMUX environment variable for tmux mode
        os.environ["USE_TMUX"] = "1"
        cfg_path = _serialise_configs_to_temp(opensloth_config, training_args)
        session = tmux_session or f"os_train_{os.getpid()}"
        run_tmux_training(
            session_name=session,
            config_file=str(cfg_path),
            gpus=opensloth_config.devices,
            auto_kill=tmux_auto_kill,
        )
        return opensloth_config, training_args
    # --- Generate-Then-Execute Path ---
    output_dir = Path(training_args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    script_path = output_dir / "train.py"

    print(f"âš™ï¸ Generating standalone training script -> {script_path}")
    script_content = _generate_training_script(opensloth_config, training_args)
    script_path.write_text(script_content)

    print("ğŸš€ Executing generated script...")
    # Use sys.executable to ensure the same Python env is used
    process = subprocess.run([sys.executable, str(script_path)], check=True)

    if process.returncode == 0:
        print("âœ… Training process completed successfully.")
    else:
        print(f"âŒ Training process failed with exit code {process.returncode}.")
    return opensloth_config, training_args



__all__ = [ "run_training"]
